#!/usr/bin/env python3
"""
Yield Curve Database Endpoint Extension for Bloomberg Gateway
Provides yield curve configurations from PostgreSQL database
"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import logging
import psycopg2
import json
import os
import subprocess

# Create router for yield curve endpoints
yield_curve_router = APIRouter(prefix="/api/yield-curves", tags=["yield-curves"])

# Request/Response models
class YieldCurveRequest(BaseModel):
    currency: str
    include_data: Optional[bool] = False  # Whether to fetch live Bloomberg data

class CurveInstrument(BaseModel):
    ticker: str
    tenor: int      # Days to maturity
    label: str      # Display label
    years: float    # Years to maturity for scaling
    instrumentType: str  # 'money_market', 'swap', or 'bond'
    order: Optional[int] = None

class YieldCurveResponse(BaseModel):
    success: bool
    currency: str
    title: str
    instruments: List[CurveInstrument]
    data: Optional[Dict[str, Any]] = None
    error: Optional[str] = None

def get_postgres_password():
    """Get PostgreSQL password from Azure Key Vault"""
    try:
        result = subprocess.run([
            'az', 'keyvault', 'secret', 'show', 
            '--vault-name', 'gzc-finma-keyvault',
            '--name', 'postgres-connection-string',
            '--query', 'value', 
            '-o', 'tsv'
        ], capture_output=True, text=True, timeout=10)
        
        if result.returncode == 0:
            connection_string = result.stdout.strip()
            if '://' in connection_string and '@' in connection_string:
                password_part = connection_string.split('://')[1].split('@')[0]
                if ':' in password_part:
                    return password_part.split(':')[1]
        
        raise ValueError("Cannot parse password from connection string")
    except Exception as e:
        logging.error(f"Failed to get password from Key Vault: {e}")
        # Fallback to environment variable
        return os.environ.get('POSTGRES_PASSWORD', '')

def get_database_connection():
    """Create database connection"""
    password = get_postgres_password()
    return psycopg2.connect(
        host='gzcdevserver.postgres.database.azure.com',
        database='gzc_platform',
        user='mikael',
        password=password,
        port=5432,
        sslmode='require'
    )

def tenor_to_label(days: int) -> str:
    """Convert tenor in days to display label"""
    if days == 1:
        return "O/N"
    elif days < 30:
        weeks = days // 7
        return f"{weeks}W" if weeks > 1 else "1W"
    elif days < 365:
        months = round(days / 30)
        return f"{months}M"
    else:
        years = round(days / 365)
        return f"{years}Y"

def get_instrument_type(ticker: str) -> str:
    """Determine instrument type from ticker"""
    ticker_upper = ticker.upper()
    
    # Money market indicators
    if any(x in ticker_upper for x in ['RATE', 'LIBOR', 'EURIBOR', 'TIBOR', 'BBSW', 'CDOR', 'PRIBOR', 'WIBOR']):
        return 'money_market'
    # Government bonds
    elif any(x in ticker_upper for x in ['USGG', 'GDBR', 'GUKG', 'GJGB', 'GSWISS', 'GCAN', 'GACGB']):
        return 'bond'
    # Everything else is likely a swap
    else:
        return 'swap'

@yield_curve_router.get("/available")
async def get_available_curves():
    """Get list of available yield curves from database"""
    conn = None
    try:
        conn = get_database_connection()
        cursor = conn.cursor()
        
        # Get all defined curves with member count
        cursor.execute("""
            SELECT 
                rcd.curve_name,
                rcd.currency,
                rcd.curve_type,
                rcd.description,
                COUNT(DISTINCT rcm.ticker_id) as member_count
            FROM rate_curve_definitions rcd
            LEFT JOIN rate_curve_memberships rcm ON rcd.id = rcm.curve_id
            WHERE rcd.active = true
            GROUP BY rcd.id, rcd.curve_name, rcd.currency, rcd.curve_type, rcd.description
            ORDER BY rcd.currency, rcd.curve_type
        """)
        
        curves = []
        for row in cursor.fetchall():
            curves.append({
                "curve_name": row[0],
                "currency": row[1],
                "curve_type": row[2],
                "description": row[3],
                "member_count": row[4]
            })
        
        return {
            "success": True,
            "curves": curves,
            "total": len(curves)
        }
        
    except Exception as e:
        logging.error(f"Database error: {e}")
        raise HTTPException(status_code=500, detail=str(e))
    finally:
        if conn:
            conn.close()

@yield_curve_router.post("/config", response_model=YieldCurveResponse)
async def get_yield_curve_config(request: YieldCurveRequest):
    """Get yield curve configuration from database"""
    conn = None
    try:
        conn = get_database_connection()
        cursor = conn.cursor()
        
        # First, find the appropriate curve for this currency
        # Priority: OIS > IRS > Government
        curve_query = """
            SELECT rcd.id, rcd.curve_name, rcd.description
            FROM rate_curve_definitions rcd
            WHERE rcd.currency = %s 
            AND rcd.active = true
            AND EXISTS (
                SELECT 1 FROM rate_curve_memberships rcm 
                WHERE rcm.curve_id = rcd.id
            )
            ORDER BY 
                CASE 
                    WHEN rcd.curve_type = 'OIS' THEN 1
                    WHEN rcd.curve_type = 'IRS' THEN 2
                    WHEN rcd.curve_type = 'GOVT' THEN 3
                    ELSE 4
                END
            LIMIT 1
        """
        
        cursor.execute(curve_query, (request.currency,))
        curve_result = cursor.fetchone()
        
        if not curve_result:
            return YieldCurveResponse(
                success=False,
                currency=request.currency,
                title=f"{request.currency} Yield Curve",
                instruments=[],
                error=f"No curve found for {request.currency}"
            )
        
        curve_id, curve_name, description = curve_result
        
        # Get all members of this curve
        member_query = """
            SELECT 
                bt.ticker,
                bt.tenor,
                rcm.order_index,
                bt.properties
            FROM rate_curve_memberships rcm
            JOIN bloomberg_tickers bt ON rcm.ticker_id = bt.id
            WHERE rcm.curve_id = %s
            ORDER BY rcm.order_index, bt.tenor
        """
        
        cursor.execute(member_query, (curve_id,))
        
        instruments = []
        for ticker, tenor, order_index, properties in cursor.fetchall():
            # Calculate years from tenor
            years = tenor / 365.0 if tenor else 0
            
            # Generate label
            label = tenor_to_label(tenor) if tenor else "N/A"
            
            # Determine instrument type
            instrument_type = get_instrument_type(ticker)
            
            instruments.append(CurveInstrument(
                ticker=ticker,
                tenor=tenor or 0,
                label=label,
                years=round(years, 3),
                instrumentType=instrument_type,
                order=order_index
            ))
        
        # Generate title
        title = description or f"{request.currency} {curve_name.replace('_', ' ')}"
        
        response = YieldCurveResponse(
            success=True,
            currency=request.currency,
            title=title,
            instruments=instruments
        )
        
        # Optionally fetch live Bloomberg data
        if request.include_data and instruments:
            # This would call the Bloomberg API with all tickers
            # For now, we'll leave this as a placeholder
            pass
        
        return response
        
    except Exception as e:
        logging.error(f"Database error: {e}")
        return YieldCurveResponse(
            success=False,
            currency=request.currency,
            title=f"{request.currency} Yield Curve",
            instruments=[],
            error=str(e)
        )
    finally:
        if conn:
            conn.close()

@yield_curve_router.post("/batch-config")
async def get_batch_yield_curves(currencies: List[str]):
    """Get multiple yield curve configurations at once"""
    results = {}
    
    for currency in currencies:
        try:
            result = await get_yield_curve_config(YieldCurveRequest(currency=currency))
            results[currency] = result.dict()
        except Exception as e:
            results[currency] = {
                "success": False,
                "error": str(e)
            }
    
    return {
        "success": True,
        "curves": results
    }

# Add this router to your main FastAPI app:
# app.include_router(yield_curve_router)